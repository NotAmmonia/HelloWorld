Docker was used to encapsulate the Java application in a self-contained, reproducible environment. Instead of relying solely on local configurations, a Dockerfile was created to specify the runtime requirements by selecting an appropriate base image, setting up a dedicated application directory, copying the compiled Java files into the container, and defining the command to execute the application. This approach allowed the developers to build a Docker image that includes all necessary dependencies and configurations, which could then be deployed and run consistently across different systems using commands like docker build and docker run. Ultimately, Docker streamlined the process by automating both the setup and execution of the Java program, ensuring that it operated reliably regardless of the underlying host environment.
Changes for Group Project 4:
This process demonstrates how to automate the build and deployment of a Java application using Docker and GitHub Actions. First, a Dockerfile is created to define how the application is packaged, using OpenJDK 23 and compiling Java files from the src directory. A personal access token from Docker Hub is then generated to allow secure authentication. Next, a GitHub Actions workflow is set up either through GitHub's UI or manually via IntelliJ, specifying steps to log in to Docker Hub, build the Docker image, and push it using the credentials stored in GitHub Secrets. Finally, once the changes are committed and pushed to the main branch, the workflow is triggered automatically, and the Docker image becomes available on Docker Hub, where it can be pulled and run using standard Docker commands.
